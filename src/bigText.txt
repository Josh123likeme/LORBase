----------------------
src\assets\Assets.java
----------------------
package assets;

import java.awt.image.BufferedImage;
import java.io.IOException;

import javax.imageio.ImageIO;

public abstract class Assets {

	private static BufferedImage defaultTexture;
	
	public static BufferedImage LoadTextureFromAssets(String path){
		
		try {
			
			return ImageIO.read(Assets.class.getResourceAsStream(path));
			
		}
		catch (IOException | IllegalArgumentException e) {
			
			System.out.println("couldn't find texture at " + path + "\nusing default texture instead");	
			
			if (defaultTexture == null) generateDefaultTexture();
			
			return defaultTexture;
			
		}
		
	}
	
	private static void generateDefaultTexture() {
		
		BufferedImage texture = new BufferedImage(2, 2, BufferedImage.TYPE_INT_ARGB);
		
		int col = (255 << 24) | (0 << 16) | (0 << 8) | 0;
		texture.setRGB(0, 0, col);
		texture.setRGB(1, 1, col);
		
		col = (255 << 24) | (170 << 16) | (45 << 8) | 170;
		texture.setRGB(1, 0, col);
		texture.setRGB(0, 1, col);
		
		defaultTexture = texture;
		
	}
	
}

-------------------------------------------
src\me\Josh123likeme\LORBase\DebugInfo.java
-------------------------------------------
package me.Josh123likeme.LORBase;

import java.awt.event.KeyEvent;
import java.util.ArrayList;
import java.util.List;

import me.Josh123likeme.LORBase.Types.Cardinal;
import me.Josh123likeme.LORBase.Types.Vector2D;

public class DebugInfo {

	public int FPS;
	public double DeltaFrame;
	
	public boolean IsDragging;
	public List<Integer> HeldKeys;
	
	public Vector2D PlayerPos;
	public Cardinal PlayerFacing;
	public Vector2D CameraPos;
	
	public double GuiScale;
	
	private String task;
	private String progress;
	
	public String getTask() throws Exception {
		
		if (task.equals(null)) throw new Exception("No task currently running");
		
		if (progress.equals(null)) {
			
			return task;
			
		}
		
		return task + " (" + progress + ")";
		
	}
	
	public void setTask(String task) {
		
		this.task = task;
		this.progress = null;
		
	}
	public void setTask(String task, String progress) {
		
		this.task = task;
		this.progress = progress;
		
	}
	public void completeTask() {
		
		this.task = null;
		this.progress = null;
		
	}
	
	public List<String> getDebugInfo() {
		
		List<String> info = new ArrayList<String>();
		
		info.add("FPS: " + FPS + " (Delta Frame: " + DeltaFrame + ")");
		info.add("Is Dragging: " + IsDragging);
		
		String keysPressed = "";
		
		for (int i = 0; i < HeldKeys.size(); i++) {
			
			keysPressed += KeyEvent.getKeyText(HeldKeys.get(i)) + ", ";
			
		}
		
		info.add("Keys pressed: " + keysPressed);
		
		info.add("Player Pos: (" + PlayerPos.X + ", " + PlayerPos.Y + ") Facing: " + PlayerFacing);
		info.add("Camera Pos: (" + CameraPos.X + ", " + CameraPos.Y + ")");
		
		info.add("GUI Scale: " + GuiScale);
		
		return info;
		
	}
	
}

-------------------------------------------
src\me\Josh123likeme\LORBase\FrameData.java
-------------------------------------------
package me.Josh123likeme.LORBase;

import me.Josh123likeme.LORBase.Types.Vector2D;

public class FrameData {

	public int Height;
	public int Width;
	public double DeltaFrame;
	
	public Vector2D CameraPosition;
	public double GuiScale;
	
	public FrameData() {}
	
}

--------------------------------------
src\me\Josh123likeme\LORBase\Game.java
--------------------------------------
package me.Josh123likeme.LORBase;

import java.awt.Canvas;
import java.awt.Color;
import java.awt.Font;
import java.awt.Graphics;
import java.awt.event.KeyEvent;
import java.awt.image.BufferStrategy;
import java.util.List;

import me.Josh123likeme.LORBase.BlockHolder.Floor;
import me.Josh123likeme.LORBase.EntityHolder.Player;
import me.Josh123likeme.LORBase.InputListener.KeyboardWitness;
import me.Josh123likeme.LORBase.InputListener.MouseWitness;
import me.Josh123likeme.LORBase.Types.Cardinal;
import me.Josh123likeme.LORBase.Types.Vector2D;

public class Game extends Canvas implements Runnable {

	private static final long serialVersionUID = 1L;

	public static final int INITIAL_WIDTH = 400, INITIAL_HEIGHT = 400;
	
	private Window window;
	private Thread thread;
	private boolean running = false;
	
	private MouseWitness mouseWitness;
	private KeyboardWitness keyboardWitness;
	
	private FrameData frameData;
	
	private DebugInfo debugInfo;
	private boolean displayDebugInfo = true;
	
	public World world;
	
	private int fps = 0;
	
	private Player player;
	
	public Game() {
		
		window = new Window(INITIAL_WIDTH, INITIAL_HEIGHT, "The Labyrinth Of Recursion", this);
		frameData = new FrameData();
		debugInfo = new DebugInfo();
		frameData.CameraPosition = new Vector2D(50, 50);
		frameData.GuiScale = 5d;
		player = new Player(new Vector2D(1, 1), Cardinal.NORTH);
		world = new World(player);
		
		initInputs();
		
	}
	
	public void initInputs() {
		
		mouseWitness = new MouseWitness();
		keyboardWitness = new KeyboardWitness();
		
		addMouseListener(mouseWitness);
		addMouseMotionListener(mouseWitness);
		addKeyListener(keyboardWitness);
		
		requestFocus();
		
	}
	
	public synchronized void start() {
		
		thread = new Thread(this);
		thread.start();
		running = true;
		
	}
	
	public synchronized void stop() {
		
		try 
		{
			thread.join();
			running = false;
		}
		
		catch(Exception e) {e.printStackTrace();}
		
	}
	
	public void run() {

		double targetfps = 10000000d;
		long targetDeltaFrame = Math.round((1d / targetfps) * 1000000000);
		long lastSecond = System.nanoTime();
		int frames = 0;
		
		long lastFrame = 0;
		
		updateFrameData();
		updateDebugInfo();
		
		frameData.DeltaFrame = targetDeltaFrame;
		
		while (running) {
			
			frames++;
			
			if (lastSecond + 1000000000 < System.nanoTime()) {
				
				fps = frames;
				
				frames = 0;
				
				lastSecond = System.nanoTime();
				
				updateInfrequent();
				
			}
			
			//starting to push frame
			
			long nextTime = System.nanoTime() + targetDeltaFrame;
			
			updatePlayer();
			
			frameData.DeltaFrame = ((double) (System.nanoTime() - lastFrame)) / 1000000000;
			
			frameData.CameraPosition.X = player.getPosition().X;
			frameData.CameraPosition.Y = player.getPosition().Y;
			
			updateFrameData();
			updateDebugInfo();
			
			lastFrame = System.nanoTime();
			
			paint();
			
			//finished pushing frame
			
			while (nextTime > System.nanoTime());
			
		}
		stop();
		
	}

	private void paint() {
	
		BufferStrategy bufferStrategy = this.getBufferStrategy();
		if(bufferStrategy == null) {
			this.createBufferStrategy(3);
			return;
		}
		Graphics g = bufferStrategy.getDrawGraphics();
		
		//basic black background to stop flashing
		g.setColor(Color.black); 
		g.fillRect(0, 0, getWidth(), getHeight());
		
		//TODO temporary scaling 
		if (keyboardWitness.getHeldKeys().contains(KeyEvent.VK_EQUALS)) {
			
			frameData.GuiScale += 0.01;
			
		}
		else if (keyboardWitness.getHeldKeys().contains(KeyEvent.VK_MINUS)) {
			
			frameData.GuiScale -= 0.01;
			
		}
		
		//put rendering stuff here
		
		world.render(g);
		
		//debugging stuff
		
		if (keyboardWitness.getHeldKeys().contains(KeyEvent.VK_F3)) displayDebugInfo = !displayDebugInfo;
		
		if (displayDebugInfo) {
			
			g.setColor(Color.white);
			g.setFont(new Font(g.getFont().getFontName(), Font.PLAIN, frameData.Height / 25)); 
			
			List<String> info = debugInfo.getDebugInfo();
			
			for (int i = 0; i < info.size(); i++) {
				
				g.drawString(info.get(i), getWidth() / 100, (getHeight() / 25) * (i + 1));
				
			}
			
		}
		
		//Main.lm.displayLabyrinth(g); //TODO debug
		
		//this pushes the graphics to the window
		bufferStrategy.show();
		
	}
	
	private void updateFrameData() {
		
		frameData.Width = getWidth();
		frameData.Height = getHeight();
		
	}
	
	public FrameData getFrameData() {
		
		return frameData;
		
	}
	
	private void updateDebugInfo() {
		
		debugInfo.FPS = fps;
		debugInfo.DeltaFrame = frameData.DeltaFrame;
		
		debugInfo.IsDragging = mouseWitness.isDragging();
		debugInfo.HeldKeys = keyboardWitness.getHeldKeys();
		
		debugInfo.PlayerPos = player.getPosition();
		debugInfo.PlayerFacing = player.getFacing();
		debugInfo.CameraPos = frameData.CameraPosition;
		
		debugInfo.GuiScale = frameData.GuiScale;
		
	}
	
	private void updatePlayer() {
		
		List<Integer> keys = keyboardWitness.getHeldKeys();
		
		Vector2D movementVector = new Vector2D(0, 0);
		
		if (keys.contains(87)) movementVector.Y -= 1;
		if (keys.contains(65)) movementVector.X -= 1;
		if (keys.contains(83)) movementVector.Y += 1;
		if (keys.contains(68)) movementVector.X += 1;

		movementVector.normalise();
		
		movementVector.X = movementVector.X * player.getMovementSpeed() * frameData.DeltaFrame;
		movementVector.Y = movementVector.Y * player.getMovementSpeed() * frameData.DeltaFrame;
		
		player.moveEntity(new Vector2D(player.getPosition().X + movementVector.X, player.getPosition().Y + movementVector.Y));

		if (movementVector.X == 0 && movementVector.Y < 0) player.setFacing(Cardinal.NORTH);
		if (movementVector.X == 0 && movementVector.Y > 0) player.setFacing(Cardinal.SOUTH);
		if (movementVector.X > 0 && movementVector.Y == 0) player.setFacing(Cardinal.EAST);
		if (movementVector.X < 0 && movementVector.Y == 0) player.setFacing(Cardinal.WEST);
		
		world.setFloor((int) player.getPosition().X, (int) player.getPosition().Y, Floor.MOGUS); //TODO remove
		
	}
	
	private void updateInfrequent() {
		
		
		
	}
	
}

--------------------------------------
src\me\Josh123likeme\LORBase\Main.java
--------------------------------------
package me.Josh123likeme.LORBase;

import me.Josh123likeme.LORBase.Generators.Generator;
import me.Josh123likeme.LORBase.Generators.LabyrinthMaze;

public class Main {

	public static Game game;
	
	public static LabyrinthMaze lm;
	
	public static void main(String[] args) {
		
		ResourceLoader.loadResources();
		
		lm = Generator.createNewLabyrinthGenerator();
		
		lm.generateMaze(10, 10);
		
		game = new Game();
		
		game.start();
		
	}
	
}

------------------------------------------------
src\me\Josh123likeme\LORBase\ResourceLoader.java
------------------------------------------------
package me.Josh123likeme.LORBase;

import java.awt.Graphics2D;
import java.awt.geom.AffineTransform;
import java.awt.image.BufferedImage;
import java.awt.image.DataBufferByte;
import java.util.HashMap;

import me.Josh123likeme.LORBase.BlockHolder.Floor;
import me.Josh123likeme.LORBase.BlockHolder.Wall;
import me.Josh123likeme.LORBase.EntityHolder.Entity;

public abstract class ResourceLoader {

	private static HashMap<Floor, BufferedImage> floorTextures = new HashMap<Floor, BufferedImage>();
	private static HashMap<Wall, BufferedImage> wallTextures = new HashMap<Wall, BufferedImage>();
	private static HashMap<Entity, BufferedImage> entityTextures = new HashMap<Entity, BufferedImage>();
	
	public static void loadResources() {
		
		floorTextures = Floor.loadTextures();
		wallTextures = Wall.loadTextures();
		entityTextures = Entity.loadTextures();
		
	}
	
	public static BufferedImage getTexture(Floor floor) {
		
		return floorTextures.get(floor);
		
	}
	
	public static BufferedImage getTexture(Wall wall) {
		
		return wallTextures.get(wall);
		
	}

	public static BufferedImage getTexture(Entity entity) {
	
	return entityTextures.get(entity);
	
	}
	
	public static BufferedImage copyImage(BufferedImage source){
		
		//courtesy of clic on stack overflow
		
	    BufferedImage bi = new BufferedImage(source.getWidth(), source.getHeight(), source.getType());
	    byte[] sourceData = ((DataBufferByte)source.getRaster().getDataBuffer()).getData();
	    byte[] biData = ((DataBufferByte)bi.getRaster().getDataBuffer()).getData();
	    System.arraycopy(sourceData, 0, biData, 0, sourceData.length);
	    return bi;
	}
	
	public static BufferedImage rotateImageByDegrees(BufferedImage source, double angle) {
		
		//courtesy of MadProgrammer on stack overflow
		
		double rads = Math.toRadians(angle);
	    double sin = Math.abs(Math.sin(rads)), cos = Math.abs(Math.cos(rads));
	    int w = source.getWidth();
	    int h = source.getHeight();
	    int newWidth = (int) Math.floor(w * cos + h * sin);
	    int newHeight = (int) Math.floor(h * cos + w * sin);

	    BufferedImage rotated = new BufferedImage(newWidth, newHeight, BufferedImage.TYPE_INT_ARGB);
	    Graphics2D g2d = rotated.createGraphics();
	    AffineTransform at = new AffineTransform();
	    at.translate((newWidth - w) / 2, (newHeight - h) / 2);

	    int x = w / 2;
	    int y = h / 2;

	    at.rotate(rads, x, y);
	    g2d.setTransform(at);
	    g2d.drawImage(source, 0, 0, null);
	    g2d.dispose();

	    return rotated;
		
	}
	
}

--------------------------------------
src\me\Josh123likeme\LORBase\TUID.java
--------------------------------------
package me.Josh123likeme.LORBase;

import java.util.Random;

public abstract class TUID {

	private static Random random = new Random();
	
	public static String generateRandomTimeStampedId() {
		
		String timestamp = String.format("%16s", Long.toHexString(System.currentTimeMillis())).replace(' ', '0');
		
		String id = "";
		
		for (int i = 0; i < 16; i++) {
			
			id += Long.toHexString(random.nextInt(16));
			
		}
		
		return timestamp + id;
		
	}
	
}

----------------------------------------
src\me\Josh123likeme\LORBase\Window.java
----------------------------------------
package me.Josh123likeme.LORBase;

import java.awt.Canvas;
import java.awt.Dimension;

import javax.swing.JFrame;


public class Window extends Canvas {

	private static final long serialVersionUID = -259832267823304864L;
	
	public Window(int width, int height, String title, Game game) {
		
		JFrame frame = new JFrame(title);
		
		frame.setPreferredSize(new Dimension(width, height));
		frame.setMaximumSize(new Dimension(width, height));
		frame.setMinimumSize(new Dimension(0, 0));	
		frame.setSize(width, height);
		frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		frame.setResizable(true);
		frame.setLocationRelativeTo(null);
		frame.setVisible(true);
		frame.add(game);	
		
	}
	
}

---------------------------------------
src\me\Josh123likeme\LORBase\World.java
---------------------------------------
package me.Josh123likeme.LORBase;

import java.awt.Graphics;
import java.awt.image.BufferedImage;
import java.util.ArrayList;

import me.Josh123likeme.LORBase.BlockHolder.Chunk;
import me.Josh123likeme.LORBase.BlockHolder.Floor;
import me.Josh123likeme.LORBase.BlockHolder.Wall;
import me.Josh123likeme.LORBase.EntityHolder.EntityBase;
import me.Josh123likeme.LORBase.EntityHolder.Player;
import me.Josh123likeme.LORBase.Generators.Generator;
import me.Josh123likeme.LORBase.Generators.SimpleMaze;
import me.Josh123likeme.LORBase.Types.Cardinal;
import me.Josh123likeme.LORBase.Types.Vector2D;

public class World {
	
	public Chunk[][] chunks;
	
	ArrayList<EntityBase> entities = new ArrayList<EntityBase>();
	
	public World(Player player) {
		
		entities.add(player);
		
		//labyrinth generation
			
		SimpleMaze generator = Generator.createNewRandomMazeGenerator();
		
		generator.generateMaze(101, 101);
		
		Floor[][] floor = generator.getFloor();
		Wall[][] wall = generator.getWall();
		
		chunks = Chunk.chunkify(floor, wall);
		
	}
	
	public void render(Graphics g) {
		
		FrameData frameData = Main.game.getFrameData();
		
		Vector2D cameraPos = frameData.CameraPosition;
		
		int blocksOnScreenX = (int) Math.ceil(frameData.Width / (16 * frameData.GuiScale));
		int BlocksOnScreenY = (int) Math.ceil(frameData.Height / (16 * frameData.GuiScale));
		
		blocksOnScreenX += Chunk.getChunkSize() * 2;
		BlocksOnScreenY += Chunk.getChunkSize() * 2;
		
		int tlx = (int) (Math.floor(frameData.CameraPosition.X) - blocksOnScreenX / 2) / Chunk.getChunkSize();
		int tly = (int) (Math.floor(frameData.CameraPosition.Y) - BlocksOnScreenY / 2) / Chunk.getChunkSize();
		int brx = (int) (Math.ceil(frameData.CameraPosition.X) + blocksOnScreenX / 2) / Chunk.getChunkSize();
		int bry = (int) (Math.ceil(frameData.CameraPosition.Y) + BlocksOnScreenY / 2) / Chunk.getChunkSize();
		
		if (tlx < 0) tlx = 0;
		if (tly < 0) tly = 0;
		if (brx > chunks[0].length - 1) brx = chunks[0].length - 1;
		if (bry > chunks.length - 1) bry = chunks.length - 1;
		
		for (int y = tly; y <= bry; y++) {
			
			for (int x = tlx; x <= brx; x++) {
				
				chunks[y][x].renderChunk(
						(int) (x * 16 * Chunk.getChunkSize() * frameData.GuiScale - frameData.CameraPosition.X * 16 * frameData.GuiScale) + frameData.Width / 2,
						(int) (y * 16 * Chunk.getChunkSize() * frameData.GuiScale - frameData.CameraPosition.Y * 16 * frameData.GuiScale) + frameData.Height / 2,
						(int) (16 * Chunk.getChunkSize() * frameData.GuiScale + 1), g);
				

			}
			
		}
		
		for (EntityBase entity : entities) {
			
			int degrees = 0;
			
			if (entity.getFacing() == Cardinal.EAST) degrees = 90;
			if (entity.getFacing() == Cardinal.SOUTH) degrees = 180;
			if (entity.getFacing() == Cardinal.WEST) degrees = 270;
			
			BufferedImage texture = ResourceLoader.rotateImageByDegrees(entity.type.getTexture(), degrees);
			
			g.drawImage(texture,
					(int) (entity.getPosition().X * 16 * frameData.GuiScale - frameData.CameraPosition.X * 16 * frameData.GuiScale) + frameData.Width / 2,
					(int) (entity.getPosition().Y * 16 * frameData.GuiScale - frameData.CameraPosition.Y * 16 * frameData.GuiScale) + frameData.Height / 2, 
					(int) (16 * frameData.GuiScale + 1),
					(int) (16 * frameData.GuiScale + 1),
					null);
			
		}
		
	}
	
	
	public void updateInfrequent() {
		
		for (EntityBase entity : entities) {
			
		}
		
	}
	
	public Floor getFloor(int x, int y) {
		
		return chunks[(int) y / 16][(int) x / 16].getFloor(x % 16, y % 16);
		
	}
	
	public Wall getWall(int x, int y) {
		
		return chunks[(int) y / 16][(int) x / 16].getWall(x % 16, y % 16);
		
	}
	
	public void setFloor(int x, int y, Floor floor) {
		
		chunks[(int) y / 16][(int) x / 16].setFloor(x % 16, y % 16, floor);
		
	}
	
	public void setWall(int x, int y, Wall wall) {
		
		chunks[(int) y / 16][(int) x / 16].setWall(x % 16, y % 16, wall);
		
	}
	
}

---------------------------------------------------
src\me\Josh123likeme\LORBase\BlockHolder\Chunk.java
---------------------------------------------------
package me.Josh123likeme.LORBase.BlockHolder;

import java.awt.Graphics;
import java.awt.image.BufferedImage;

public class Chunk {
	
	private static final int chunkSize = 16;
	private static final int defaultBlockTextureSize = 16;
	
	private Floor[][] floor = new Floor[chunkSize][chunkSize];
	private Wall[][] wall = new Wall[chunkSize][chunkSize];
	
	private BufferedImage chunkTexture;
	
	private boolean chunkModified;
	
	
	public Floor getFloor(int x, int y) {
		
		return floor[y][x];
		
	}
	
	public Wall getWall(int x, int y) {
		
		return wall[y][x];
		
	}
	
	public void setFloor(int x, int y, Floor floor) {
		
		if (this.floor[y][x] == floor) return;
		
		this.floor[y][x] = floor;
		
		chunkModified = true;
		
	}
	
	public void setWall(int x, int y, Wall wall) {
		
		if (this.wall[y][x] == wall) return;
		
		this.wall[y][x] = wall;
		
		chunkModified = true;
		
	}
	
	public void renderChunk(int x, int y, int size, Graphics g) {
		
		if (chunkModified) {
			
			stitchTexture();
			
			chunkModified = false;
			
		}
		
		g.drawImage(chunkTexture, x, y, size, size, null);
		
	}

	private void stitchTexture() {
		
		chunkTexture = new BufferedImage(chunkSize * defaultBlockTextureSize, chunkSize * defaultBlockTextureSize, BufferedImage.TYPE_INT_ARGB);
		
		for (int y = 0; y < chunkSize; y++) {
			
			for (int x = 0; x < chunkSize; x++) {

				if(floor[y][x] == null) continue;
				
				chunkTexture.getGraphics().drawImage(floor[y][x].getTexture(),
						x * defaultBlockTextureSize, y * defaultBlockTextureSize, defaultBlockTextureSize, defaultBlockTextureSize, null);
				
			}
			
		}

		for (int y = 0; y < chunkSize; y++) {
			
			for (int x = 0; x < chunkSize; x++) {

				if(wall[y][x] == null) continue;
				
				chunkTexture.getGraphics().drawImage(wall[y][x].getTexture(),
						x * defaultBlockTextureSize, y * defaultBlockTextureSize, defaultBlockTextureSize, defaultBlockTextureSize, null);
				
			}
			
		}
		
	}
	
	public static Chunk[][] chunkify(Floor[][] floor, Wall[][] wall) {
		
		Chunk[][] chunks = new Chunk[(int) Math.ceil((double) floor.length / chunkSize)][(int) Math.ceil((double) floor[0].length / chunkSize)];
		
		for (int yOffset = 0; yOffset < chunks.length; yOffset++) {
			
			for (int xOffset = 0; xOffset < chunks[0].length; xOffset++) {
				
				Chunk chunk = new Chunk();
				
				for (int y = 0; y < chunkSize; y++) {
					
					for (int x = 0; x < chunkSize; x++) {
						
						try {
							
							chunk.setFloor(x, y, floor[yOffset * chunkSize + y][xOffset * chunkSize + x]);
							chunk.setWall(x, y, wall[yOffset * chunkSize + y][xOffset * chunkSize + x]);
							
						} catch(ArrayIndexOutOfBoundsException e) { }
						
						
						
					}
					
				}
				
				chunks[yOffset][xOffset] = chunk;
				
				chunk.stitchTexture();
				
			}
			
		}
		
		return chunks;
		
	}
	
	public static int getChunkSize() {
		
		return chunkSize;
		
	}
	
}

---------------------------------------------------
src\me\Josh123likeme\LORBase\BlockHolder\Floor.java
---------------------------------------------------
package me.Josh123likeme.LORBase.BlockHolder;

import java.awt.image.BufferedImage;
import java.util.HashMap;

import assets.Assets;
import me.Josh123likeme.LORBase.ResourceLoader;

public enum Floor {

	LABYRINTH_FLOOR("LABYRINTH_FLOOR.png"),
	MOGUS("MOGUS.png"), //for testing high res textures
	DEBUG_16("DEBUG_16.png"),
	DEBUG_32("DEBUG_32.png"),
	DEBUG_64("DEBUG_64.png"),
	
	;
	
	String texturePath;
	
	Floor(String texturePath){
		
		this.texturePath = texturePath;
		
	}
	
	public static HashMap<Floor, BufferedImage> loadTextures() {
		
		HashMap<Floor, BufferedImage> textures = new HashMap<Floor, BufferedImage>();
		
		for (int i = 0; i < Floor.values().length; i++) {
			
			BufferedImage image = null;
				
		    image = Assets.LoadTextureFromAssets("textures/block/" + Floor.values()[i].texturePath);
			
			textures.put(Floor.values()[i], image);
			
		}
		
		return textures;
		
	}
	
	public BufferedImage getTexture() {
		
		return ResourceLoader.getTexture(this);
		
	}
	
}

--------------------------------------------------
src\me\Josh123likeme\LORBase\BlockHolder\Wall.java
--------------------------------------------------
package me.Josh123likeme.LORBase.BlockHolder;

import java.awt.image.BufferedImage;
import java.util.HashMap;

import assets.Assets;
import me.Josh123likeme.LORBase.ResourceLoader;

public enum Wall {

	LABYRINTH_WALL("LABYRINTH_WALL.png"),
	
	;
	
	String texturePath;
	
	Wall(String texturePath){
		
		this.texturePath = texturePath;
		
	}
	
	public static HashMap<Wall, BufferedImage> loadTextures() {
		
		HashMap<Wall, BufferedImage> textures = new HashMap<Wall, BufferedImage>();
		
		for (int i = 0; i < Wall.values().length; i++) {
			
			BufferedImage image = null;
			
			image = Assets.LoadTextureFromAssets("textures/block/" + Wall.values()[i].texturePath);
			
			textures.put(Wall.values()[i], image);
			
		}
		
		return textures;
		
	}
	
	public BufferedImage getTexture() {
		
		return ResourceLoader.getTexture(this);
		
	}
	
}

-----------------------------------------------------
src\me\Josh123likeme\LORBase\EntityHolder\Entity.java
-----------------------------------------------------
package me.Josh123likeme.LORBase.EntityHolder;

import java.awt.image.BufferedImage;
import java.util.HashMap;

import assets.Assets;
import me.Josh123likeme.LORBase.ResourceLoader;

public enum Entity {

	PLAYER("PLAYER.png"),
	
	;
	
	
	String texturePath;
	
	Entity(String texturePath){
		
		this.texturePath = texturePath;
		
	}
	
	public static HashMap<Entity, BufferedImage> loadTextures(){
		
		HashMap<Entity, BufferedImage> textures = new HashMap<Entity, BufferedImage>();
		
		for (int i = 0; i < Entity.values().length; i++) {
			
			BufferedImage image = null;

		    image = Assets.LoadTextureFromAssets("textures/entity/" + Entity.values()[i].texturePath);
			
			textures.put(Entity.values()[i], image);
			
		}
		
		return textures;
		
	}
	
	public BufferedImage getTexture() {
		
		return ResourceLoader.getTexture(this);
		
	}
	
}

---------------------------------------------------------
src\me\Josh123likeme\LORBase\EntityHolder\EntityBase.java
---------------------------------------------------------
package me.Josh123likeme.LORBase.EntityHolder;
import me.Josh123likeme.LORBase.Types.Cardinal;
import me.Josh123likeme.LORBase.Types.Vector2D;

public abstract class EntityBase {
	
	public final Entity type;	
	private final double size;
	
	private Vector2D pos;
	private double baseMovementSpeed; // m/s
	private double movementSpeed;
	private Cardinal facing;
	
	public EntityBase(Vector2D initPos, Entity type, double baseMovementSpeed, double size, Cardinal facing){
		
		pos = initPos;
		this.type = type;
		this.baseMovementSpeed = baseMovementSpeed;
		this.size = size;
		this.facing = facing;
		
	}
	
	public Vector2D getPosition() {
		
		return pos;
		
	}
	
	public double getMovementSpeed() {
		
		return baseMovementSpeed;
		
	}
	
	public Cardinal getFacing() {
		
		return facing;
		
	}
	
	public void setFacing(Cardinal facing) {
		
		this.facing = facing;
		
	}
	
	public void moveEntity(Vector2D pos) {
		
		double x = pos.X;
		double y = pos.Y;
		
		this.pos = pos;
		
	}

}

----------------------------------------------------------
src\me\Josh123likeme\LORBase\EntityHolder\ICollidable.java
----------------------------------------------------------
package me.Josh123likeme.LORBase.EntityHolder;

public interface ICollidable {
	
}

-----------------------------------------------------
src\me\Josh123likeme\LORBase\EntityHolder\Player.java
-----------------------------------------------------
package me.Josh123likeme.LORBase.EntityHolder;

import me.Josh123likeme.LORBase.Types.Cardinal;
import me.Josh123likeme.LORBase.Types.Vector2D;

public class Player extends EntityBase implements ICollidable {
	
	public Player(Vector2D initPos, Cardinal facing) {
		super(initPos, Entity.PLAYER, 5, 0.8, facing);
		
	}
	
}

------------------------------------------------------
src\me\Josh123likeme\LORBase\Generators\Generator.java
------------------------------------------------------
package me.Josh123likeme.LORBase.Generators;

public abstract class Generator {
	
	//simple maze
	public static SimpleMaze createNewRandomMazeGenerator() {
		
		return new SimpleMaze();
		
	}
	
	//normal labyrinth generation
	public static LabyrinthMaze createNewLabyrinthGenerator() {
		
		return new LabyrinthMaze();
		
	}
	
}

----------------------------------------------------------
src\me\Josh123likeme\LORBase\Generators\LabyrinthMaze.java
----------------------------------------------------------
package me.Josh123likeme.LORBase.Generators;

import java.awt.Color;
import java.awt.Graphics;
import java.util.Random;

import me.Josh123likeme.LORBase.BlockHolder.Floor;
import me.Josh123likeme.LORBase.BlockHolder.Wall;
import me.Josh123likeme.LORBase.Types.Vector2D;

public class LabyrinthMaze {

	final int smallRoomSize = 16;
	final int hallwayWidth = 4;
	final double chanceOfRoomPlace = 0.3d;
	
	private Floor[][] floor;
	private Wall[][] wall;
	
	private int width;
	private int height;
	
	private int[][] template;
	
	private static Random random = new Random();
	
	public void generateMaze(int width, int height) {
		
		floor = new Floor[height][width];
		wall = new Wall[height][width];
		
		this.width = width;
		this.height = height;
		
		template = new int[height][width];
		
		generate();
		
	}
	
	private void generate() {
		
		for (int y = 0; y < height; y++) {
			
			for (int x = 0; x < width; x++) {
				
				template[y][x] = 0;
				
			}
			
		}
		
		//generating room map
		
		int roomCounter = 1;
		
		for (Room room : Room.values()) {
			
			for (int y = 0; y < height; y++) {
				
				for (int x = 0; x < width; x++) {
					
					if (willRoomFit(room, x, y)) {
						
						if (random.nextDouble() > chanceOfRoomPlace && !room.equals(Room.SINGLE)) continue;
						
						for (Vector2D vec : room.getOriginPositions()) {
							
							template[(int) (vec.Y + y)][(int) (vec.X + x)] = roomCounter;
								
						}
						
						roomCounter++;
						
					}
					
				}
				
			}
			
		}
		
	}
	
	private Boolean willRoomFit(Room room, int x, int y) {
		
		for (Vector2D vec : room.getOriginPositions()) {
			
			if (vec.X + x >= width || vec.Y + y >= height) return false;
			
			if (template[(int) (vec.Y + y)][(int) (vec.X + x)] != 0) return false;
			
		}
		
		return true;
		
	}
	
	public void displayLabyrinth(Graphics g) {
		
		for (int y = 0; y < height; y++) {
			
			for (int x = 0; x < width; x++) {
				
				g.setColor(hashColor(template[y][x] - 1));
				
				g.fillRect(x * 64, y * 64, 64, 64);
				
			}
			
		}
		
	}
	
	private Color hashColor(int value) {
		
		
		//69 provided by Emily Conlon
		//196 provided by Bradley Conlon
		//56 provided by Michael Aldridge
		
		return new Color((value * 69) % 256, (value * 196) % 256, (value * 56) % 256);
		
	}
	
	private enum Room {

		BOX(new Vector2D(0,0), new Vector2D(1,0), new Vector2D(1,1), new Vector2D(0,1)),
		// OO
		// OO
		L_0(new Vector2D(0,0), new Vector2D(1,0), new Vector2D(0,1)),
		// OO
		// O
		L_1(new Vector2D(0,0), new Vector2D(1,0), new Vector2D(1,1)),
		// OO
		//  O
		L_2(new Vector2D(1,0), new Vector2D(1,1), new Vector2D(0,1)),
		//  O
		// OO
		L_3(new Vector2D(0,0), new Vector2D(0,1), new Vector2D(1,1)),
		// O
		// OO
		SUPERTALL_0(new Vector2D(0,0), new Vector2D(0,1), new Vector2D(0,2)),
		// O
		// O
		// O
		SUPERTALL_1(new Vector2D(0,0), new Vector2D(1,0), new Vector2D(2,0)),
		// OOO
		TALL_0(new Vector2D(0,0), new Vector2D(0,1)),
		// O
		// O
		TALL_1(new Vector2D(0,0), new Vector2D(1,0)),
		// OO
		SINGLE(new Vector2D(0,0)),
		// O
		
		;
		
		private final Vector2D[] originPositions;
		
		Room(Vector2D o0){
			
			 originPositions = new Vector2D[] {o0};
			
		}
		
		Room(Vector2D o0, Vector2D o1){
			
			 originPositions = new Vector2D[] {o0, o1};
			
		}
		
		Room(Vector2D o0, Vector2D o1, Vector2D o2){
			
			 originPositions = new Vector2D[] {o0, o1, o2};
			
		}
		
		Room(Vector2D o0, Vector2D o1, Vector2D o2, Vector2D o3){
			
			 originPositions = new Vector2D[] {o0, o1, o2, o3};
			
		}
		
		public Vector2D[] getOriginPositions() {
			
			return originPositions;
			
		}
		
	}
	
}

-------------------------------------------------------
src\me\Josh123likeme\LORBase\Generators\SimpleMaze.java
-------------------------------------------------------
package me.Josh123likeme.LORBase.Generators;

import java.util.Random;

import me.Josh123likeme.LORBase.BlockHolder.Floor;
import me.Josh123likeme.LORBase.BlockHolder.Wall;
import me.Josh123likeme.LORBase.Types.Vector2D;

public class SimpleMaze {

	private Floor[][] floor;
	private Wall[][] wall;
	
	public Floor[][] getFloor(){
		
		return floor;
		
	}
	
	public Wall[][] getWall(){
		
		return wall;
		
	}
	
	private static Random random = new Random();
	
	public Boolean[][] generateMaze(int width, int height) {
		
		floor = new Floor[height][width];
		wall = new Wall[height][width];
		
		Boolean[][] maze = new Boolean[height][width];
		
		for (int i = 0; i < maze[0].length; i++) {
			
			maze[0][i] = true;
			
		}
		
		for (int y = 1; y < maze.length - 1; y++) {
			
			maze[y][0] = true;
			
			for (int x = 1; x < maze[0].length - 1; x++) {
				
				maze[y][x] = false;
				
			}
			
			maze[y][maze[0].length - 1] = true;
			
		}
		
		for (int i = 0; i < maze[0].length; i++) {
			
			maze[maze.length - 1][i] = true;
			
		}
		
		goForward(new Vector2D(2, (int) (2 * (height / 4))), new Vector2D(1,0), maze);
		
		for (int y = 0; y < floor.length; y++) {
			
			for (int x = 0; x < floor[0].length; x++) {
				
				if (maze[y][x]) wall[y][x] = Wall.LABYRINTH_WALL;
				
				else floor[y][x] = Floor.LABYRINTH_FLOOR;

			}
			
		}
		
		return maze;
		
	}
	
	private static void goForward(Vector2D pos, Vector2D dir, Boolean[][] maze) {
		
		int maxDistance = maxDistance(pos, dir, maze);
		
		if (maxDistance <= 0) return;
		
		int distance = 2 * random.nextInt(10);
		
		if (distance > maxDistance) distance = maxDistance;
			
		for (int i = 0; i < distance; i++) {
			
			pos.X += dir.X;
			pos.Y += dir.Y;
				
			maze[(int) pos.Y][(int) pos.X] = true;
			
		}
		
		int[] order = new int[] {0,1,2,3};
		
		for (int i = 0; i < 10; i++) {
			
			int one = random.nextInt(4);
			int two = random.nextInt(4);
			
			int temp = order[one];			
			order[one] = order[two];			
			order[two] = temp;
			
		}
		
		for (int i = 0; i < order.length; i++) {
			
			switch (order[i]) {
			
			case 0:
				
				goForward(new Vector2D(pos.X, pos.Y), new Vector2D(1,0), maze);
				
				break;
				
			case 1:
				
				goForward(new Vector2D(pos.X, pos.Y), new Vector2D(-1,0), maze);
				
				break;
				
			case 2:
				
				goForward(new Vector2D(pos.X, pos.Y), new Vector2D(0,-1), maze);
				
				break;
				
			case 3:
				
				goForward(new Vector2D(pos.X, pos.Y), new Vector2D(0,1), maze);
				
				break;
			
			}
			
		}
		
	}
	
	private static int maxDistance(Vector2D pos, Vector2D dir, Boolean[][] maze) {
		
		int x = (int) pos.X;
		int y = (int) pos.Y;
		
		int distance = 0;
		
		do  {	
			
			x += 2 * dir.X;
			y += 2 * dir.Y;
			
			distance += 2;

		}
		while (!maze[y][x]);
		
		return distance - 2;
		
	}
	
}

---------------------------------------------------------------
src\me\Josh123likeme\LORBase\InputListener\KeyboardWitness.java
---------------------------------------------------------------
package me.Josh123likeme.LORBase.InputListener;

import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class KeyboardWitness implements KeyListener {

	/*
3 -- Cancel
8 -- Backspace
9 -- Tab
10 -- Enter
12 -- Clear
16 -- Shift
17 -- Ctrl
18 -- Alt
19 -- Pause
20 -- Caps Lock
21 -- Kana
24 -- Final
25 -- Kanji
27 -- Escape
28 -- Convert
29 -- No Convert
30 -- Accept
31 -- Mode Change
32 -- Space
33 -- Page Up
34 -- Page Down
35 -- End
36 -- Home
37 -- Left
38 -- Up
39 -- Right
40 -- Down
44 -- Comma
45 -- Minus
46 -- Period
47 -- Slash
48 -- 0
49 -- 1
50 -- 2
51 -- 3
52 -- 4
53 -- 5
54 -- 6
55 -- 7
56 -- 8
57 -- 9
59 -- Semicolon
61 -- Equals
65 -- A
66 -- B
67 -- C
68 -- D
69 -- E
70 -- F
71 -- G
72 -- H
73 -- I
74 -- J
75 -- K
76 -- L
77 -- M
78 -- N
79 -- O
80 -- P
81 -- Q
82 -- R
83 -- S
84 -- T
85 -- U
86 -- V
87 -- W
88 -- X
89 -- Y
90 -- Z
91 -- Open Bracket
92 -- Back Slash
93 -- Close Bracket
96 -- NumPad-0
97 -- NumPad-1
98 -- NumPad-2
99 -- NumPad-3
100 -- NumPad-4
101 -- NumPad-5
102 -- NumPad-6
103 -- NumPad-7
104 -- NumPad-8
105 -- NumPad-9
106 -- NumPad *
107 -- NumPad +
108 -- NumPad ,
109 -- NumPad -
110 -- NumPad .
111 -- NumPad /
112 -- F1
113 -- F2
114 -- F3
115 -- F4
116 -- F5
117 -- F6
118 -- F7
119 -- F8
120 -- F9
121 -- F10
122 -- F11
123 -- F12
127 -- Delete
128 -- Dead Grave
129 -- Dead Acute
130 -- Dead Circumflex
131 -- Dead Tilde
132 -- Dead Macron
133 -- Dead Breve
134 -- Dead Above Dot
135 -- Dead Diaeresis
136 -- Dead Above Ring
137 -- Dead Double Acute
138 -- Dead Caron
139 -- Dead Cedilla
140 -- Dead Ogonek
141 -- Dead Iota
142 -- Dead Voiced Sound
143 -- Dead Semivoiced Sound
144 -- Num Lock
145 -- Scroll Lock
150 -- Ampersand
151 -- Asterisk
152 -- Double Quote
153 -- Less
154 -- Print Screen
155 -- Insert
156 -- Help
157 -- Meta
160 -- Greater
161 -- Left Brace
162 -- Right Brace
192 -- Back Quote
222 -- Quote
224 -- Up
225 -- Down
226 -- Left
227 -- Right
240 -- Alphanumeric
241 -- Katakana
242 -- Hiragana
243 -- Full-Width
244 -- Half-Width
245 -- Roman Characters
256 -- All Candidates
257 -- Previous Candidate
258 -- Code Input
259 -- Japanese Katakana
260 -- Japanese Hiragana
261 -- Japanese Roman
262 -- Kana Lock
263 -- Input Method On/Off
512 -- At
513 -- Colon
514 -- Circumflex
515 -- Dollar
516 -- Euro
517 -- Exclamation Mark
518 -- Inverted Exclamation Mark
519 -- Left Parenthesis
520 -- Number Sign
521 -- Plus
522 -- Right Parenthesis
523 -- Underscore
524 -- Windows
525 -- Context Menu
61440 -- F13
61441 -- F14
61442 -- F15
61443 -- F16
61444 -- F17
61445 -- F18
61446 -- F19
61447 -- F20
61448 -- F21
61449 -- F22
61450 -- F23
61451 -- F24
65312 -- Compose
65368 -- Begin
65406 -- Alt Graph
65480 -- Stop
65481 -- Again
65482 -- Props
65483 -- Undo
65485 -- Copy
65487 -- Paste
65488 -- Find
65489 -- Cut
	 */
	
	private ArrayList<Integer> keysPressed = new ArrayList<Integer>();
	
	@Override
	public void keyTyped(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void keyPressed(KeyEvent e) {
		
		if (!keysPressed.contains(e.getKeyCode())) keysPressed.add(e.getKeyCode());
		
	}

	@Override
	public void keyReleased(KeyEvent e) {
		
		try {
			
			keysPressed.removeAll(Collections.singleton(e.getKeyCode()));
			
		}
		catch (Exception exception) {}
		
	}
	
	public List<Integer> getHeldKeys(){
		
		return keysPressed;
		
	}

}

------------------------------------------------------------
src\me\Josh123likeme\LORBase\InputListener\MouseWitness.java
------------------------------------------------------------
package me.Josh123likeme.LORBase.InputListener;

import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.event.MouseMotionListener;

public class MouseWitness implements MouseListener, MouseMotionListener {

	private int mouseX, mouseY;
	private boolean dragging;
	
	@Override
	public void mouseDragged(MouseEvent e) {
		
		mouseX = e.getX();
		mouseY = e.getY();
		
	}

	@Override
	public void mouseMoved(MouseEvent e) {
		
		dragging = false;
		
		mouseX = e.getX();
		mouseY = e.getY();
		
	}

	@Override
	public void mouseClicked(MouseEvent e) {
		/*
		
		 if (e.getButton() == MouseEvent.BUTTON1)
		 
		 */
		
	}

	@Override
	public void mousePressed(MouseEvent e) {
		dragging = true;
		
	}

	@Override
	public void mouseReleased(MouseEvent e) {
		dragging = false;
		
	}

	@Override
	public void mouseEntered(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void mouseExited(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}

	public int getMouseX() {
		
		return mouseX;
		
	}
	
	public int getMouseY() {
		
		return mouseY;
		
	}
	
	public boolean isDragging() {
		
		return dragging;
		
	}
	
}

------------------------------------------------------
src\me\Josh123likeme\LORBase\ItemHolder\DEV_SWORD.java
------------------------------------------------------
package me.Josh123likeme.LORBase.ItemHolder;

public class DEV_SWORD {

	
	
}

----------------------------------------------------
src\me\Josh123likeme\LORBase\ItemHolder\Essence.java
----------------------------------------------------
package me.Josh123likeme.LORBase.ItemHolder;

public enum Essence {

	//vial essentia
	
	SANA,
	
	//other essentia
	
	REPARARE,
	COMPRESSE,
	
	;
	
}

-------------------------------------------------
src\me\Josh123likeme\LORBase\ItemHolder\Item.java
-------------------------------------------------
package me.Josh123likeme.LORBase.ItemHolder;

import java.awt.image.BufferedImage;

import assets.Assets;

public abstract class Item {
	
	protected BufferedImage defaultTexture;
	
	/**
	 * used for accessing the texture
	 * @return
	 */
	public BufferedImage getTexture() {
		
		if (defaultTexture == null) loadTextures();
		
		return defaultTexture;
		
	}
	
	/**
	 * loads textures into memory
	 */
	protected void loadTextures() {
		
		Assets.LoadTextureFromAssets("textures/item/" + this.getClass().getName() + ".png");
		
	}
	
}

-------------------------------------------------
src\me\Josh123likeme\LORBase\ItemHolder\VIAL.java
-------------------------------------------------
package me.Josh123likeme.LORBase.ItemHolder;

import java.awt.image.BufferedImage;

public class VIAL extends Item {

	private static final int maxCompressionLevel = 10;
	int compressionLevel;
	double maxCapacity;
	
	Essence essence;
	double essenceVolume;
	
	public BufferedImage getTexture() {
		
		if (essence == null) return defaultTexture;
		
		return defaultTexture;
		
	}
	
	public void addEssence(int amount) {
		
		if (essenceVolume + amount > maxCapacity) throw new IllegalArgumentException("cannot increase amount of essence above maximum");
		
		essenceVolume += amount;
		
	}
	
	public void addEssence(Essence essence, int amount) {
		
		if (this.essence != null) {
			
			if (essence != this.essence) throw new IllegalArgumentException("you can only add essence of the same type");
			
		}
		
		if (essenceVolume + amount > maxCapacity) throw new IllegalArgumentException("cannot increase amount of essence above maximum");
		
		essenceVolume += amount;
		
	}
	
	public void upgradeCompressionLevel() {
		
		if (compressionLevel + 1 > maxCompressionLevel) throw new IllegalArgumentException("cannot increase compression level above maximum");
		
		compressionLevel++;
		
		maxCapacity = getCapacityAtLevel(compressionLevel);
		
	}

	public int getCapacityAtLevel(int level) {
		
		if (level <= 0) throw new IllegalArgumentException("level must be positive");
		
		return (int) (level >= 10 ? 100 : 0.5 * (level + 3) * (level + 4));
		
	}
	
}

------------------------------------------------
src\me\Josh123likeme\LORBase\Types\Cardinal.java
------------------------------------------------
package me.Josh123likeme.LORBase.Types;

public enum Cardinal {

	NORTH(),
	EAST(),
	SOUTH(),
	WEST()
	
	;
	
}

------------------------------------------------
src\me\Josh123likeme\LORBase\Types\Vector2D.java
------------------------------------------------
package me.Josh123likeme.LORBase.Types;

public class Vector2D {
	
	public double X, Y;
	
	public Vector2D(double x, double y) {
		
		X = x;
		Y = y;
		
	}
	
	public void normalise() {
		
		double mod = Math.sqrt(X*X + Y*Y);
		
		if (mod == 0) return;
		
		X = X / mod;
		Y = Y / mod;
		
	}

}

